---
name: PROD NOCODE BACKEND DEPLOYMENT
run-name: '[${{ github.event_name }} - ${{ github.ref_name }}] backend deployment by @${{ github.actor }}'

on:
  workflow_dispatch

permissions:
  id-token: write
  contents: read
  pull-requests: write

env:
  # Terraform
  terraformS3Key: ${{ secrets.ADEX_INTERNAL_STAGE }}/adexltd/adex-coder/main.tfstate
  terraformModulesGithubOrg: ${{ github.repository_owner}}
  awsAccountNumber: ${{ secrets.ADEX_INTERNAL_STAGE }}
  githubToken: ${{ secrets.ADEX_GITHUB_TOKEN }}
  terraformS3Acl: bucket-owner-full-control
  terraformBucket: adex-terraform-state
  terraformDynamo: adex-terraform-state
  oidcRoleName: Github-OIDC-role
  terraformS3Encryption: true
  terraformVersion: 1.9.5
  awsRegion: us-east-1

  # Kubernetes
  otlpEndpoint: http://infix-shared-collector.elk.svc.cluster.local
  serviceName: infix-prod-backend-traces
  helm: ./helm/backend
  otlpPort: 4318

jobs:
  deploy:
    name: prod nocode backend application
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4.1.1

      - name: Configure aws credentials
        uses: aws-actions/configure-aws-credentials@v4
        id: creds
        with:
          role-to-assume: arn:aws:iam::${{ env.awsAccountNumber }}:role/${{ env.oidcRoleName }}
          role-session-name: OIDCSession
          aws-region: ${{ env.awsRegion }}

      - name: Install JQ Tool
        uses: mbround18/install-jq@v1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: ${{ env.terraformVersion }}
          terraform_wrapper: false

      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash

      - name: Setup git repo credentials for terraform modules
        run: |
          git config --global \
          url."https://git:${{ env.githubToken }}@github.com/${{ env.terraformModulesGithubOrg }}".insteadOf \
          "https://github.com/${{ env.terraformModulesGithubOrg }}"
        shell: sh

      - name: Terraform Init
        id: init
        working-directory: ${{ env.workdir }}
        run: terraform init -backend-config="bucket=${{ env.terraformBucket }}" -backend-config="dynamodb_table=${{ env.terraformDynamo }}" -backend-config="key=${{ env.terraformS3Key}}" -backend-config="region=${{ env.awsRegion }}" -backend-config="acl=${{ env.terraformS3Acl }}" -backend-config="encrypt=${{ env.terraformS3Encryption }}"

      - name: Get the necessary resource name for .env file
        uses: mathiasvr/command-output@v2.0.0
        id: get-resource-name
        with:
          run: |
            state_file_name=${{ env.terraformS3Key }}
            aws s3 cp s3://${{ env.terraformBucket }}/${{ env.terraformS3Key }} $state_file_name

            # Cluster name
            cluster_name=$(terraform output --json -state=$state_file_name | jq -r '.cluster_name.value')
            echo "CLUSTER_NAME=$cluster_name" >> "$GITHUB_OUTPUT"

            # Database name
            db_name=$(terraform output --json -state=$state_file_name | jq -r '.db_instance_name_app.value')
            echo "DB_NAME=$db_name" >> "$GITHUB_OUTPUT"

            # Database endpoint
            endpoint=$(terraform output --json -state=$state_file_name | jq -r '.db_instance_endpoint_app.value')
            echo "DB_ENDPOINT=$endpoint" >> "$GITHUB_OUTPUT"

            # Database username
            username=$(terraform output --json -state=$state_file_name | jq -r '.db_instance_username_app.value')
            echo "DB_USER=$username" >> "$GITHUB_OUTPUT"

            # ECR repository name
            ecr_backend_repo_name=$(terraform output --json -state=$state_file_name | jq -r '.ecr_backend_repo_name.value')
            echo "ECR_BACKEND_REPO_NAME=$ecr_backend_repo_name" >> "$GITHUB_OUTPUT"

            # Cognito IRSA role arn
            prod_backend_cognito_irsa_role_arn=$(terraform output --json -state=$state_file_name | jq -r '.cognito_irsa_role_arn.value[0]')
            echo "PROD_BACKEND_COGNITO_IRSA_ROLE_ARN=$prod_backend_cognito_irsa_role_arn" >> $GITHUB_OUTPUT

            # Cognito user pool id
            user_pool_id=$(terraform output --json -state=$state_file_name | jq -r '.user_pool_id.value')
            echo "USER_POOL_ID=$user_pool_id" >> "$GITHUB_OUTPUT"

            # Cognito user pool client id
            client_id=$(terraform output --json -state=$state_file_name | jq -r '.client_id.value[0]')
            echo "CLIENT_ID=$client_id" >> "$GITHUB_OUTPUT"

            # Cognito user pool client secrets
            client_secrets=$(terraform output --json -state=$state_file_name | jq -r '.client_secrets.value[0]')
            echo "CLIENT_SECRETS=$client_secrets" >> "$GITHUB_OUTPUT"

            # Database secret for infix backend
            db_password=$(terraform output --json -state=$state_file_name | jq -r '.app_secret.value')
            echo "DB_PASSWORD=$db_password" >> "$GITHUB_OUTPUT"

      # Build Docker image
      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region ${{ env.awsRegion }} | docker login --username AWS --password-stdin ${{ env.awsAccountNumber }}.dkr.ecr.${{ env.awsRegion }}.amazonaws.com

      - name: Update kubeconfig for EKS Cluster
        working-directory: ${{ env.workdir }}
        run: |
          aws eks update-kubeconfig --name ${{ steps.get-resource-name.outputs.CLUSTER_NAME }} --region ${{ env.awsRegion }}

      - name: Build and push Docker image
        run: |
          docker build -t backend:latest .
          docker tag backend:latest ${{ env.awsAccountNumber }}.dkr.ecr.${{ env.awsRegion }}.amazonaws.com/${{ steps.get-resource-name.outputs.ECR_BACKEND_REPO_NAME }}:${{ github.sha }}
          docker push ${{ env.awsAccountNumber }}.dkr.ecr.${{ env.awsRegion }}.amazonaws.com/${{ steps.get-resource-name.outputs.ECR_BACKEND_REPO_NAME }}:${{ github.sha }}

      - name: Creating environment variables
        run: |
          cat << EOF > env.yaml
          POSTGRES_USER: $(echo -n "${{ steps.get-resource-name.outputs.DB_USER }}" | base64)
          POSTGRES_PASSWORD: $(echo -n "${{ steps.get-resource-name.outputs.DB_PASSWORD }}" | base64)
          POSTGRES_HOST: $(echo -n "${{ steps.get-resource-name.outputs.DB_ENDPOINT }}" | base64 -w 0)
          POSTGRES_PORT: $(echo -n "5432" | base64)
          POSTGRES_DB: $(echo -n "${{ steps.get-resource-name.outputs.DB_NAME }}" | base64)
          POSTGRES_URL: $(echo -n "postgresql://${{ steps.get-resource-name.outputs.DB_USER }}:${{ steps.get-resource-name.outputs.DB_PASSWORD }}@${{ steps.get-resource-name.outputs.DB_ENDPOINT }}:5432/${{ steps.get-resource-name.outputs.DB_NAME }}" | base64 -w 0)
          FRONTEND_URL: $(echo -n "https://infix.cloud" | base64)
          GITHUB_CLIENT_ID: $(echo -n "${{ secrets.ADEX_GITHUB_CLIENT_ID }}" | base64)
          GITHUB_CLIENT_SECRET: $(echo -n "${{ secrets.ADEX_GITHUB_CLIENT_SECRET }}" | base64)
          GITHUB_API_URL: $(echo -n "https://api.github.com" | base64)
          SECRET_KEY: $(echo -n "RANDOM_HASH_SECRET_KEY" | base64)
          ALGORITHM: $(echo -n "HS256" | base64)
          ACCESS_TOKEN_EXPIRE_MINUTES: $(echo -n "30" | base64)
          DATE_FORMAT: $(echo -n "%Y-%m-%d" | base64)
          CLIENT_ID: $(echo -n "${{ steps.get-resource-name.outputs.CLIENT_ID }}" | base64)
          CLIENT_SECRET: $(echo -n "${{ steps.get-resource-name.outputs.CLIENT_SECRETS }}" | base64)
          USER_POOL_ID: $(echo -n "${{ steps.get-resource-name.outputs.USER_POOL_ID }}" | base64)
          REGION: $(echo -n "${{ env.awsRegion }}" | base64)
          CODER_API_KEY: $(echo -n "${{ secrets.CODER_API_KEY }}" | base64)
          CODER_HOSTED_URL: $(echo -n "https://coder.infix.cloud" | base64)
          GITHUB_APP_PRIVATE_KEY: $(echo -n "prod" | base64)
          SENDER_MAIL: $(echo -n "infix-support@adex.ltd" | base64)
          SERVICE_NAME: $(echo -n "${{ env.serviceName }}" | base64)
          ENVIRONMENT: $(echo -n "production" | base64)
          OTLP_COLLECTOR_ENDPOINT: $(echo -n "${{ env.otlpEndpoint }}" | base64)
          OTLP_COLLECTOR_PORT: $(echo -n "4318" | base64)
          EOF

      - name: Deploy Helm chart to prod namespace
        run: |
          helm upgrade --install backend ${{ env.helm }} -n prod --set env="prod" --set image.repository=${{ env.awsAccountNumber }}.dkr.ecr.${{ env.awsRegion}}.amazonaws.com/${{ steps.get-resource-name.outputs.ECR_BACKEND_REPO_NAME }},image.tag=${{ github.sha }} --set serviceAccount.annotations."eks\.amazonaws\.com/role-arn"=${{ steps.get-resource-name.outputs.PROD_BACKEND_COGNITO_IRSA_ROLE_ARN }} --set-file secretData=env.yaml
